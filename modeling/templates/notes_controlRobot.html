{% extends "layout.html" %}

{% block title %}
Управление роботом
{% endblock %}

{% block body %}
<h1>Управление роботом через конечный автомат</h1>
<p>
В этом разделе даётся обзор того, как управлять роботом с помощью конечного автомата.
Более подробное описание робота смотри в  <a href="https://vadimgb.github.io/psets/infrastructureGuide.html">руководстве</a>.
</p>

<p>Мы можем реализовать контроллер робота как автомат ввод которого объект класса
io.SensorInput, вывод объект io.Action.
</p>
<p>Первый пример - автомат, который всегда выводит действие, io.Action(), 
оно задаёт нулевые скорость движения и вращения.
Когда выполняется метод setup, создаётся behvior, так мы будем называть 
автомат, преобразующий io.SensorInputs в io.Action.
</p>
Когда нажимаем кнопку Start, метод step:
<ul>
	<li>
		Получает данные от сенсоров, вызывая io.SensorInput();
	</li>
	<li>
		Отправляет эти данные в brain автомат, вызывая его метод step;
	</li>
	<li>
		Берет io.Action возвращённое brain и вызывает execute метод,
		который действительно посылает моторам робота команды.
	</li>
</ul>
<p>Вы можете поставить флаг verbose в True, если хотите видеть подробный вывод 
данных.</p>
<p>Внутри Soar brain, вы имеете доступ к объекту robot, который существует
всё время выполнения brain, и даёт место для хранения важных объектов (как
автомат делающий всю работу).
</p>
<pre>
<code class="language-python">
import lib601.sm as sm
from soar.io import io

class StopSM(sm.SM):
	def getNextValues(self, state, inp):
		return (None, io.Action())


def setup():
	robot.behavior = StopSM()
	robot.behavior.start()

def step():
	robot.behavior.step(io.SensorInpuit(), verbose = False).exectue()
	</code>
</pre>


<h2>Вращение</h2>
<p>Представьте, что мы хотим, чтобы робот поворачивался 
на фиксированный угол, скажем, на 90 градусов, влево от того места, 
где он находился, когда он начал выполнять определенное поведение.
Мы можем использовать одометрию робота для приблизительного измерения 
его местоположения в произвольной системе координат; но чтобы узнать, 
насколько оно изменилось с тех пор, как мы начали, нам нужно 
сохранить некоторую информацию в состоянии.
</p>

<p>Вот класс, который определяет конечный автомат Rotate.
Во время инициализации требуется желаемое изменение направления.
</p>
<pre>
<code class="language-python">
class RotateTSM(sm.SM):
	rotationalGain = 3.0
	angleEpsilon = 0.01
	startState  = 'start'

	def __init__(self, headingDelta):
		self.headingDelta headingDelta
</code>
</pre>
<p>Когда придет время запустить эту машину, 
мы хотели бы посмотреть на текущий курс робота (delta), 
добавить желаемое изменение курса и сохранить результат 
в нашем состоянии как желаемый курс.
Затем, чтобы проверить, выполнено ли поведение, 
мы хотим увидеть, достаточно ли близок текущие направление к желаемому.
Поскольку метод done не имеет доступа к входным данным машины 
(это свойство только состояний), нам необходимо включить 
текущую тэту в состояние.
Итак, состояние машины (thetaDesired, thetaLast).
</p>

<p>Таким образом, метод getNextValues просматривает состояние; 
если это специальный символ "start", это означает, что у машины 
ранее не было возможности наблюдать за вводом и видеть текущий курс, 
поэтому она вычисляет желаемый курс (путем добавления 
желаемого изменения к текущему курсу, а затем вызов служебной 
процедуры, чтобы убедиться, что полученный угол находится между 
плюсом и минусом \(\pi\)), и возвращает его и текущий курс.
В противном случае мы сохраняем компонент состояния thetaDesired 
и просто получаем новое значение направления на входе.
Мы генерируем действие со скоростью вращения, которое будет 
вращать в направлении желаемого курса со скоростью, 
пропорциональной величине угловой ошибки.
</p>
<pre>
<code class="language-python">
def getNextValues(self, state, inp): 
	currentTheta = inp.odometry.theta 
	if state == ’start’: 
		thetaDesired = \ 
		util.fixAnglePlusMinusPi(currentTheta + self.headingDelta)
	else: 
		(thetaDesired, thetaLast) = state 
	newState = (thetaDesired, currentTheta) 
	action = io.Action(rvel = self.rotationalGain * \ 
		util.fixAnglePlusMinusPi(thetaDesired - currentTheta))
	return (newState, action)
</code>
</pre>
<p>
Наконец, мы должны сказать, для каких состоиний  метод done возваращает True .
Очевидно, что для состояния 'start' done вернёт False ; 
но мы закончили, если самая последняя тета из одометрии 
находится в пределах некоторого допуска self.angleEpsilon 
от желаемого курса.
</p>
<pre>
<code class="langage-python">
def done(self, state): 
	if state == ’start’: 
		return False 
	else: 
		(thetaDesired, thetaLast) = state 
		return util.nearAngle(thetaDesired, thetaLast, self.angleEpsilon)
</code>
</pre>
<div class="alert alert-light">
Задание:
Измените эту машину так, чтобы она вращалась на угол, 
чтобы вы могли задать ей 2 \(\pi\) или минус 2 \(\pi\), 
чтобы она делала полный оборот.
</div>
{% endblock %}
