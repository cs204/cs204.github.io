class Высказывание:

    def вычислить(self, модель):
        """Вычисляет высказывание"""
        raise Exception("Нечего вычислять")
    
    def символы(self):
        """set символов входящих в высказывание"""
        return set()

    @classmethod
    def проверить(cls, высказывание):
        if not isinstance(высказывание, Высказывание):
            raise TypeError("Не является высказыванием")

            

class Символ(Высказывание):
    def __init__(self, имя):
        self.имя = имя

    def __repr__(self):
        return self.имя

    def вычислить(self, модель):
        try:
            return модель[self.имя]
        except KeyError:
            raise Exception(f"{self.имя} нет в модели")

    def символы(self):
        return {self.имя}


class Не(Высказывание):
    def __init__(self, операнд):
        Высказывание.проверить(операнд)
        self.операнд = операнд

    def вычислить(self, модель):
        return not self.операнд.вычислить(модель)

    def символы(self):
        return self.операнд.символы()


class И(Высказывание):
    def __init__(self, *операнды):
        for операнд in операнды:
            Высказывание.проверить(операнд)
        self.операнды = list(операнды)

    def вычислить(self, модель):
        return all([операнд.вычислить(модель) for операнд in self.операнды])

    def символы(self):
        return set.union(*[операнд.символы() for операнд in self.операнды])

    def добавить(self, операнд):
        self.операнды.append(операнд)


class Или(Высказывание):
    def __init__(self, *операнды):
        for операнд in операнды:
            Высказывание.проверить(операнд)
        self.операнды = операнды

    def вычислить(self, модель):
        return any([операнд.вычислить(модель) for операнд in self.операнды])

    def символы(self):
        return set.union(*[операнд.символы() for операнд in self.операнды])


class Импликация(Высказывание):
    def __init__(self, посылка, следствие): 
        Высказывание.проверить(посылка)
        Высказывание.проверить(следствие)
        self.посылка = посылка
        self.следствие = следствие

    def вычислить(self, модель):
        return  (not self.посылка.вычислить(модель)) or self.следствие.вычислить(модель)

    def символы(self):
        return set.union(self.посылка.символы(), self.следствие.символы())


class Эквивалентность(Высказывание):
    def __init__(self, левый, правый): 
        Высказывание.проверить(левый)
        Высказывание.проверить(правый)
        self.левый = левый
        self.правый = правый

    def вычислить(self, модель):
        return  ((self.левый.вычислить(модель) 
                and  self.правый.вычислить(модель)) 
                or (not self.левый.вычислить(модель) 
                    and  not self.правый.вычислить(модель))) 

    def символы(self):
        return set.union(self.левый.символы(), self.правый.символы())


def проверка_рекурсия(знания, запрос, символы, модель):
    """Рекурсивная проверка следования из знаний запроса"""
    
    # Каждому символу модели присвоено значение
    if len(символы) == 0:
        if знания.вычислить(модель):
            return запрос.вычислить(модель)
        return True

    else:
        # Выбираем один из оставшихся символов
        остаток = символы.copy()
        символ = остаток.pop()

        # Создаём модель, где этот символ истинен.
        модель_истина = модель.copy()
        модель_истина[символ] = True

        # Создаём модель, где этот символ ложен.
        модель_ложь = модель.copy()
        модель_ложь[символ] = False

        # 
        return (проверка_рекурсия(знания, запрос, остаток, модель_истина) 
                and проверка_рекурсия(знания, запрос, остаток, модель_ложь))


def проверка_моделей(знания, запрос):
    """Проверяет, что из знаний вытекает запрос."""

    # Объединяем символы из знаний и запроса 
    символы = set.union(знания.символы(), запрос.символы())
    
    return проверка_рекурсия(знания, запрос, символы, {})

