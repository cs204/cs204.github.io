{% extends "layout.html" %}
{% block tytle %}
Сапёр
{% endblock %}


{% block body %}

	<div style="display:none;">
			<img id="flag" src="data/minesweeper/images/flag.png">
			<img id="mine" src="data/minesweeper/images/mine.png">
	</div>

	<canvas oncontextmenu="event.preventDefault();" id="canvas" width="400" height="400" style="background-color:rgb(200, 200, 200);"></canvas>
	<br>
	<button type = "button" id="start">Начать</button>
	<button type = "button" id = "ai_move">Ход ИИ</button>
	<script src="data/minesweeper/js/index.js" type="module"></script>

<head><h1>Сапёр</h1></head>


<p>Сапёр - это игра-головоломка, состоящая из ячеек, где в 
некоторых ячейках скрыты мины. Нажатие на ячейку, содержащую
мину, взрывает мину и приводит к проигрышу игры. При нажатии на
безопасную ячейку (т.е. в которой нет мины) отображается число,
указывающее, сколько мин в соседних ячейках, которые находятся 
на одну клетку левее, правее, вниз, вверх или по диагонали от данной клетки.
</p>

<p>Например, в этой 3х3 игре "Сапёр" три значения 1 означают, что у каждой
из этих ячеек есть одна соседняя, которая содержит мину. Четыре нулевых значения
указывают на то, что у каждой из этих ячеек нет соседней мины.</p>
<img src="data/minesweeper/safe_cells.png">
<p>Имея эту информацию можно логически вывести, что в нижней правой ячейке должна
быть мина, а в верхней левой мины нет, ибо только в этом случае числовые метки
на остальных ячейках будут корректны.</p>

<p>Цель игры - пометить каждую ячейку с миной флажком. Поставить флажок можно, 
щёлкнув правой кнопкой мыши по ячейке.</p>

<h2>Логика высказываний</h2>
<p>Вашей целью в этом задании будет создание ИИ, способного играть в "Сапёра".
Напомним, что агент, основанный на знаниях, принимает решения, рассматривая свою 
базу знаний, делая вывод из этих знаний.</p>

<p>Один из способов представления знаний ИИ об 
игре "Сапёр" - сделать каждую ячейку пропозициональной переменной, которая
будет истинной, если ячейка содержит мину, и ложной в противном случае.</p>

<p>К какой информации имеет доступ ИИ? Каждый раз, когда нажимается безопасная 
ячейка ИИ будет узнавать её число. Рассмотрим следующую доску  "Сапёра", 
где средняя ячейка была открыта, а другие были помечены идентификационными буквами
для обсуждения.</p>
<img src="data/minesweeper/middle_safe.png">

<p>Какая информация у нас есть сейчас? Похоже, теперь мы
знаем, что в одной из восьми соседних ячеек - мина.</p>
<pre>
<code>
Or(A, B, C, D, E, F, G, H)
</code>
</pre>
Но на самом деле мы знаем больше, чем говорит это выражение.
Приведённое выше логическое высказывание выражает идею о том,
что по крайней мере одно из восьми высказываний истинно. 
Но мы можем сделать более сильное утверждение: мы знаем, что ровно
одно из восьми высказываний верно. Это даёт нам пропозициональное 
высказывание приведённое ниже.</p>
<pre>
<code>
Or(
    And(A, Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),
    And(Not(A), B, Not(C), Not(D), Not(E), Not(F), Not(G), Not(H)),
    And(Not(A), Not(B), C, Not(D), Not(E), Not(F), Not(G), Not(H)),
    And(Not(A), Not(B), Not(C), D, Not(E), Not(F), Not(G), Not(H)),
    And(Not(A), Not(B), Not(C), Not(D), E, Not(F), Not(G), Not(H)),
    And(Not(A), Not(B), Not(C), Not(D), Not(E), F, Not(G), Not(H)),
    And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), G, Not(H)),
    And(Not(A), Not(B), Not(C), Not(D), Not(E), Not(F), Not(G), H)
)
</code>
</pre>
<p>Это очень сложное выражение! И это просто для того,
чтобы выразить, что означает для ячейки число 1 в ней.
Если ячейка имеет 2 или 3 или какое-либо другое значение, то
выражение будет ещё длиннее.</p>

<p>Для игры с сеткой 8х8 понадобилось бы 64 пропозициональных символа,
и 2^64 возможных моделей для проверки, что слишком много для компьютера.
Нам надо найти другое представление знаний.</p>


<h2>Представление знаний</h2>
<p>Вместо этого мы будем представлять знания для нашего ИИ, как
показано ниже.</p>
<pre>
<code>
{A, B, C, D, E, F, G, H} = 1
</code>
</pre>

<p>Каждое логическое предложение в этом представлении состоит из двух
частей: набора клеток на поле, которые участвуют в предложении и числа,
представляющего сколько из них, содержащих мины. Приведённое выше предложение
говорит, что из клеток A, B, C, D, E, F, G, H ровно одна содержит мину.</p>

<p>Чем удобно это  представление? Рассмотрим игру ниже.</p>
<img src="data/minesweeper/infer_safe.png">

<p>Используя знание левого нижнего числа, мы могли бы записать
{D, E, G} = 0, означающее, что 0  клеток из D, E, G содержат мины.
Каждый раз, когда у нас есть предложение, счётчик которого равен 0, мы
знаем, что все ячейки этого предложения безопасны.</p>

<p>Точно также рассмотрим игру ниже.</p>
<img src="data/minesweeper/infer_mines.png">

<p>Наш ИИ построил бы предложение {E, F, G} = 3. Мы можем сделать 
вывод, что все E, F, H являются минами. В более общем случае, каждый
раз, когда число ячеек равно числу мин, мы знаем, 
что все ячейки этого предложения должны быть минами.</p>

<p>Мы хотим, чтобы наши предложения касались только ячеек, которые ещё
неизвестны ни как безопасные, ни как минные. Это означает, что, как только мы
узнаём, является клетка миной или нет, мы можем обновить наши предложения, чтобы
упростить их и, возможно, сделать новые выводы.</p>

<p>Например, если бы наш ИИ знал предложение {A, B, C}=2, у нас ещё не было бы
достаточной информации, чтобы сделать какой-либо вывод. Но если бы нам сказали,
что C безопасна, то мы бы вообще удалили C из предложения, оставив {A,  B} = 2.
Последнее позволяет сделать новые выводы.</p>

<p>Точно так же, если бы наш ИИ знал предложение {A, B, C} = 2, и нам сказали бы,
что C - это мина, мы могли бы удалить C из предложения и уменьшить значение счётчика, что даёт {A, B} = 1. Если только две из A, B, C являются минами и мы знаем C мина, тогда среди A, B только одна мина.</p>

<img src="data/minesweeper/subset_inference.png">

<p>Рассмотрим следующие два предложения. Из 1 средней ячейки верхнего ряда наш ИИ
построит предложение {A, B, C} = 1. Из средней ячейки нижнего ряда следует
предложение {A, B, C, D, E} = 2. Мы могли бы построить новое предложение, 
что {D, E} = 1. Так только две из A, B, C, D, E являются минами и только одна из
A, B, C является миной, тогда это есть причина, что только одна мина D, E.</p>

<p>В более общем случае каждый раз, когда у нас есть 
два предложения множество1 = счётчик1 и множество2 = счётчкик2, 
где множество1 является подмножеством множества2, мы можем 
построить новое предложение множество2 - множество1 = счётчик2 - счётчик1.
Рассмотрите пример приведённый выше, чтобы убедиться что вы поняли.</p>

<p>Используя этот метод представления  знаний, мы можем написать агента ИИ,
который сможет собирать знания об игре "Сапёр" и выбирать ячейки, которые он
считает безопасными.</p>

<p>Выпишем правила:</p>

<ul>
	<li>
		Каждый раз, когда у нас есть предложение, счётчик которого равен 0, мы
		знаем, что все ячейки этого предложения безопасны.</li>
	<li>
		Каждый раз, когда число ячеек равно числу мин, мы знаем, 
		что все ячейки этого предложения должны быть минами.</li>
	<li>
		Каждый раз, когда у нас есть 
		два предложения множество1 = счётчик1 и множество2 = счётчкик2, 
		где множество1 является подмножеством множества2, мы можем 
		построить новое предложение множество2 - множество1 = счётчик2 - счётчик1.</li>

</ul>

<h2>Начало</h2>
<ul>
	<li>Загрузите код <a href="./data/knowledge/minesweeper.zip">дистрибутива</a> и распакуйте его.
		<br>
<code>
<pre>
wget https://cs204.github.io/psets/data/knowledge/minesweeper.zip
unzip minesweeper.zip
cd minesweeper
</code>
</pre>
	</li>
	<li>В директории проекта выполните pip3 install -r requirement.txt, чтобы установить нужные пакеты.
	</li>
</ul>

<h2>Пояснение</h2>
<p>В проекте есть два основных файла: runner.py, minesweeper.py.
Файл runner.py был созданы для вас,  содержит
все необходимое для создания графического интерфейса игры. 
Файл minesweeper.py нужен
для реализации ИИ игры. Когда вы определите 
все необходимые функции в minesweeper.py,
вы сможете запустить игру, выполнив python runner.py. 
В code.cs50.io вам понадобится дополнительно 
выбрать слева cs50->GUI.</p>

<p>Откройте файл minesweeper.py, чтобы понять, 
что там есть. В этом файле определены три класса: 
Minesweeper, который управляет игрой;
Sentence, который реализует логические высказывания, 
содержащие набор ячеек и количество мин в них; 
MinesweeperAI, который делает выводы о том, какие действия
следует предпринять, основываясь на знаниях.</p>

<p>Minsweeper класс был полностью реализован для вас. Каждая ячейка
это пара (i, j), где i - номер строки (от 0 до высота - 1) и
j - номер столбца (от 0 до ширина - 1).
</p>
<p>Каждый объект класса Sentence имеет свойство cells - 
множество ячеек и count - число заминированных из них.
Функции known_mines и known_safes нужны для определения 
по высказыванию, какие ячейки содержат мины, а какие нет.

Класс содержит функции mark_mine и mark_safe для обновления информации о ячейках.
</p>

<p>MinesweeperAI реализует ИИ, который может играть в "Сапёра". Класс отслеживает ряд значений.
moves_made содержит ячейки на которые уже нажали, поэтому ИИ знает, что не нужно их снова выбирать.
mines содержит ячейки, известные как мины. safes содержит ячейки, которые считаются безопасными.
knowledge содержит список всех предложений, которые ИИ считает истинными.</p>

<p>mark_mine функция добавляет ячейку к mines, что бы ИИ знал, что это мина. Она также
перебирает все предложения известные ИИ, и информирует их о том, что ячейка является миной,
чтобы предложение себя изменило соответственно этой информации. make_safe функция делает подобное, 
но для ячеек безопасных.</p>

<p>Функции add_knowledge, make_safe_move, make_random_move оставлены для вас.</p>

<h2>Задание</h2>
<p>Закончите определение классов Sentence, MinesweeperAI в файле minesweeper.py.
 </p>
 <p>В классе Sentence завершите реализации known_mines, known_safes, mark_mine и mark_safe.</p>
 <ul>
	 <li>known_mines функция должна возвращать ячейки из cells, о которых известно, 
		 что они являются минами.</li>
	 <li>known_safe функция должна возвращать все ячейки из cells, которые безопасны.</li>
	 <li>mark_mine функция должна сначала проверить, является ли ячейка одной из ячеек, включённых в предложение.
		 <ul>
			 <li>Если ячейка в предложении, функция должна обновить предложение, чтобы ячейка больше не была в предложении,
				 но по-прежнему представляла логически правильное предложение, учитывая, что ячейка, как известно, 
				 является миной.</li>
			 <li>Если ячейки нет в предложении, то никаких действий не требуется.</li>
		 </ul>
	 </li>
	 <li>Функция mark_safe должна сначала проверить, является ли ячейка одной из ячеек, включённых в предложение.
		 <ul>
			 <li>Если ячейка находится в предложении, функция должна обновить предложение, 
				 чтобы ячейка больше не была в предложении, но по-прежнему представляла 
				 логически правильное предложение, учитывая, что эта ячейка известна как безопасная.
			 </li>
			 <li>Если ячейки нет в предложении, то никаких действий не требуется.</li>
		 </ul>
	 </li>
 </ul>
 <p>В классе MinesweeperAI завершите реализацию add_knowledge, make_safe_move и make_random_move.</p>
 <ul>
	 <li>add_knowledge должен принимать ячейку (задаваемую числом) и ее соответствующий счетчик, а также обновлять this.mines, this.safes, this.moves_made и this.knowledge с любой новой информацией, которую ИИ может вывести, учитывая эта ячейка известна как безопасная ячейка с соседними минами.
		 <ul>
			 <li>Функция должна пометить ячейку как один из сделанных в игре ходов.</li>
			 <li>Функция должна пометить ячейку как безопасную, обновив также все предложения, содержащие эту ячейку.</li>
			 <li>Функция должна добавить новое предложение в базу знаний ИИ на основании значения ячейки и числа мин 
				 в соседних ячейках. Не забудьте включить в предложение только те ячейки, состояние которых ещё не определено.
			 </li>
			 <li>Если на основе любого из предложений в this.knowledge новые ячейки могут быть помечены 
				 как безопасные или как мины, то функция должна это сделать.</li>
			 <li>Если на основе любого из предложений в this.knowledge можно вывести новые предложения 
				 (используя метод подмножества, описанный в разделе "Представление знаний"), 
				 то эти предложения также следует добавить в базу знаний.</li>
			 <li>Обратите внимание, что каждый раз, когда вы вносите какие-либо изменения в знания своего ИИ, 
				 можно сделать новые выводы, которые раньше были невозможны. Убедитесь, 
				 что эти новые выводы добавлены в базу знаний, если это возможно.</li>
		 </ul>
	 </li>
	 <li>make_safe_move должна возвращать ход, заведомо безопасный.
		 <ul>
			 <li>Возвращаемый ход должен быть известен как безопасный, а не уже сделанный ход.</li>
			 <li>Если безопасное перемещение не может быть гарантировано, функция должна возвращать undefined.</li>
			 <li>Функция не должна изменять self.moves_made, self.mines, self.safes или self.knowledge.</li>
		 </ul>
	 </li>
	 <li>make_random_move должен возвращать случайный ход.
		 <ul>
			 <li>Эта функция будет вызываться, если безопасное перемещение невозможно: если ИИ не знает, 
				 куда двигаться, вместо этого он выберет случайное перемещение.</li>
			 <li>Ход не должен быть ходом, который уже был сделан.</li>
			 <li>Ход не должен быть ходом, который известен как мина.</li>
			 <li>Если такие перемещения невозможны, функция должна возвращать undefined.</li>
		 </ul>
	 </li>
 </ul>

	 

<h3>Как проверить</h3>
Чтобы проверить правильность выполнения задания, выполните команду
<pre>
<kbd>npx cs204 2023/minesweeper local</kdbd>
</pre>

<h2>Как отправить на проверку</h2> 
<ol>
	<li>Для отправки на проверку выполните команду
		<pre>
<kbd>npx cs204 2023/minesweeper</kdbd>
</pre>
	</li>

	<li>В <a href="http://90.188.117.161:8080/character/pset/2023/minesweeper/c">форме</a> укажите адрес игры на сайте.</li>
</ol>	

	<br>
		Свои оценки вы можете посмотреть на <a href="http://90.188.117.161:8080">http://90.188.117.161:8080</a>.
	</br>



{% endblock %}

