{% extends "layout.html" %}
{% block title %}
Управление роботом
{% endblock %}
{% block body %}
<h1>Управление рботом</h1>
<p>Скачайте и установите 6.01 программное обеспечение</p>
<pre>
<code>
sudo apt update
sudo apt install idle-python2.7
wget https://vaimgb.github.io/psets/data/lib601.zip
uznip lib601.zip
cd lib601/
sudo python2 setup.py install
</code>
</pre>

<h2>Простые мозги</h2>
<p>'brain'- программа задающая поведение робота.
Процесс конструирования и запуска программы описан
в <a href="infrastructureGuide.html">руководстве</a>.
</p>
<div class="alert alert-light">
Цель:
Создать автомат "brain" для контролирования
робота, сначала в soar симуляторе, зачем реального робота.
<ul>
	<li>Запустить brain в soar и записать путь робота</li>
	<li>Изменить brain, чтобы робот вращался на месте</li>
	<li>Запустить brain на роботе Pioneer</li>
</ul>
</div>

<div class="alert alert-light">
	Ресурсы:
	<ul>
		<li>Скачайте smBrain.py: простой brain робота,
			он использует 6.01 класс автомата sm.
			<pre>
			<code>
			wget https://vadimgb.github.io/psets/data/smBrain.py
			</code>
			</pre>
		</li>
	</ul>
</div>

<p>Детальное руководство:
<ol>
	<li>
		Запустите brain в симуляторе 
		<ol> 
			<li>В Activity bar слева выберите кнопку cs50. Нажмите кнопку GUI. Разрешите создать всплывающее окно.
				У вас должна появиться вкладка, на которой GUI программы будут выводить свои окна.</li>
			<li>В окне терминала наберите soar &. </li> 
			<li>Нажмите soar  кнопку Simulator  и дважды щёлкните 
			файл tutorial.py.  Это загружает в 
			симулятор робота конкретный виртуальный мир.
			</li>

			<li> 
				Нажмите кнопку Brain в Soar, перейдите к 
				designLab02/smBrain.py и нажмите открыть.  
				Это загружает определение конечного 
				автомата в симулятор робота.  Этот конечный 
				автомат описывает действия, которые робот 
				предпримет в ответ на полученную информацию 
				об окружающем его виртуальном мире.
			</li>
			<li> 
				Нажмите кнопку Soar Start и дайте роботу 
				немного поработать.
			</li>
			<li>
				Нажмите кнопку Stop.
			</li>
			<li> 
				Обратите внимание на полученный график; он 
				показывает «слизистый след» пути, по которому 
				следовал робот, пока работал brain.  
				Можете просто закрыть окно.  
				(Если вы не хотите, чтобы brain оставлял 
				следы слизи, вы можете установить для аргумента 
				drawSlimeTrail конструктора Robot-Graphics в файле 
				smBrain.py значение False).
			</li> 
		</ol>
	</li>
	<li>
		Измените brain и запустите.
		<ol>
			<li>
				Откройте файл smBrain.py в редакторе.

			</li>
			<li> 
				Конечный автомат, управляющий действиями 
				робота, определяется определением MySMClass.  
				Представьте себе, что этот конечный 
				автомат принимает сенсорные данные в 
				качестве входных данных и возвращает 
				в качестве выходных данных инструкции
				роботу о том, как себя вести.  
				Объект io.Action, возвращаемый в 
				качестве выходных данных методом 
				getNextValues класса MySmClass, 
				сообщает роботу, как изменить своё 
				поведение, и имеет два важных для 
				нас атрибута:
				<ul>
					<li>fvel: определяет скорость
						движения робота вперед (в метрах в секунду)
					</li>
					<li> rvel: указывает скорость вращения робота (в радианах в секунду), 
						где положительное вращение происходит против часовой стрелки.
					</li>
				</ul> 
			</li> 
			<li>
				Найдите в мозгу место, где задаются 
				скорости, а затем измените его так, 
				чтобы моделируемый робот вращался на месте.
			</li>
			<li>
				Сохраните файл.
			</li>
			<li> 
				Вернитесь в окно soar и нажмите кнопку Reload brain.
			</li>
			<li> 
				Запустите мозг, нажав кнопку Start, а затем кнопку Stop.
			</li>
		</ol>
	</li>
	<li>
		Выполните это на роботе
		<ol>
			<li> 
				Подключите робота к ноутбуку, 
				убедившись, что кабель закреплён 
				вокруг ручки в задней части робота.
			</li>
			<li> 
				Включите робота с помощью переключателя на боковой панели.
			</li>
			<li> 
				Нажмите кнопку Pioneer на панели 
				Soar, чтобы выбрать робота. Вы 
				должны услышать тикающий звук 
				датчиков сонара.
			</li>
			<li> 
				Один партнёр должен отвечать за 
				безопасность робота.  
				Не допускайте запутывания кабеля 
				в колёсах робота.  Если робот 
				начнёт убегать от вас, 
				поднимите его, а затем выключите с
				помощью переключателя на роботе.
			</li>
			<li> 
				Нажмите кнопку Start.
			</li>
		</ol>
	</li>
</ol>

<h2>Сонары</h2>

<div class="alert alert-light">
Цель: Исследуйте поведение датчиков сонара и модифицируйте мозг робота, 
чтобы он держался на определённом расстоянии от препятствия.
Не тратьте более 10–15 минут на эксперименты с сонаром.
</div>

<p>Аргумент inp метода getNextValues MySMClass является экземпляром класса 
soar.io.SensorInput, который мы импортировали как io.SensorInput.

У него есть два атрибута: одометрия и сонары.

В этой лабораторной работе мы будем использовать атрибут sonars, 
который содержит список из 8 чисел, представляющих показания 8 датчиков 
сонара робота, которые дают показания расстояния в метрах.
Первое чтение в списке (индекс 0) — крайнее левое (с
перспектива робота) датчик; 
показания крайнего правого датчика являются последними (индекс 7).
</p>
<h4>Детальное руководство:</h4>
<ul>
	<li>
		Измените brain так, чтобы он устанавливал обе скорости равными 0, 
		и раскомментируйте строку
		<pre>
		<code class="language-python">
		print inp.sersors[3]
		</code>
		</pre> 
		Перезагрузите мозг и запустите его. 
		Он напечатает значение inp.sonars[3], которое является показанием 
		одного из датчиков сонара, обращённого вперёд.
	</li>
	<li> 
		С какого расстояния можно получить надёжные показания расстояния? 
		Что произойдёт, если самое близкое окажется дальше?
	</li>
	<li> 
		Что происходит с вещами, находящимися очень близко к датчику?
	</li> 
	<li>
	Влияет ли на показания изменение угла между датчиком эхолота и поверхностью, 
	на которую он направлен?  Зависит ли такое поведение от материала поверхности? 
	Попробуйте пузырчатую плёнку против гладкого пенопласта.
	</li>
	<li> 
		Теперь установите для аргумента sonarMonitor конструктора RobotGraphics 
		значение True.  
		Перезагрузите мозг и запустите его.  
		Откроется окно, в котором графически показаны все показания сонара.  
		Длина луча соответствует показаниям; красные лучи соответствуют 
		«нет действительного измерения».  Проверьте работу всех ваших эхолотов, 
		блокируя их по очереди.  
		Если вы заметили проблему с каким-либо из датчиков, обратитесь к персоналу.
	</li>
</ul>

<p>Заставьте робота двигаться вперёд примерно на 0.5 метра до препятствия перед 
ним и удерживайте его на этом расстоянии, даже если препятствие движется вперёд и назад.
Сделайте это, отредактировав метод getNextValues MySMClass; нет необходимости 
менять какую-либо другую часть мозга.
Не устанавливайте скорость движения вперёд выше 0.3 (или ниже -0.3). 
Отладьте его в моделировании, нажав кнопку Simulator в  Soar и выбрав файл tutorial.py.
Как только все станет хорошо, запустите его на реальном роботе, 
нажав кнопку Pioneer в программе Soar.
</p>
<div class="alert alert-light"> 
	Проверка 1: Продемонстрируйте преподавателю свой brain, 
	умеющий держать дистанцию, на настоящем роботе.
</div>

<h2>Движение вдоль препятствия</h2>
<div class="alert alert-light">
Наша цель сейчас — построить конечный автомат, который будет управлять роботом 
для выполнения более сложной задачи:
<ol> 
	<li>
		Когда рядом ничего нет, он должен двигаться прямо вперёд.
	</li>
	<li> 
		Как только он достигнет препятствия впереди, он должен следовать вдоль него, 
		сохраняя правую сторону робота на расстоянии от 0.3 до 0.5 метра от препятствия.
	</li>
</ol>
</div>
<p>
Нарисуйте диаграмму перехода состояний, описывающую каждую отдельную ситуацию 
(состояние) во время следования за стеной и то, каким должен быть желаемый 
результат (действие) и следующее состояние в ответ на возможные входные данные 
(показания сонара) в этом состоянии.

Начните с рассмотрения случая, когда робот движется прямо вперёд через пустое пространство, 
а затем подумайте о входных условиях, с которыми вы сталкиваетесь, 
и о новых состояниях, которые возникают в результате.
Тщательно продумайте, что делать как на внутренних, так и на внешних углах.
Помните, что роботы вращаются вокруг своих центральных точек.
Постарайтесь свести количество состояний к минимуму.
</p>

<div class="alert alert-light"> 
	Проверка 2: Покажите свою диаграмму перехода состояний преподавателю.  
	Проясните, каковы условия перехода состояний и какие действия 
	связаны с каждым состоянием.
</div>

<p>
Скопируйте текущий файл smBrain.py в borderBrain.py 
и измените его, чтобы реализовать конечный автомат, определённый вашей диаграммой.
Обязательно определите атрибут startState и метод getNextValues.
</p>

<p>Постарайтесь, чтобы ваше решение было простым и общим.
Используйте хорошие методы разработки программного обеспечения: 
не повторяйте код, используйте вспомогательные процедуры с мнемоническими 
именами, старайтесь использовать несколько произвольных констант 
и давайте тем, которые вы используете, описательные имена.
</p>
<p>Для отладки добавьте операторы печати, которые показывают 
соответствующие входные данные, текущее состояние, следующее 
состояние и выходное действие.
</p>

<p>
Запишите слизистый след (slime trail) симулированного робота, 
следующий за последовательностью стен; 
убедитесь, что он может обрабатывать внешние и внутренние углы.
Обходить очень острые углы или крутые повороты, 
такие как буква L в tutorial.py, не обязательно, но это очень хорошо.
</p>
<div class="alert alert-light"> 
	Проверка 3: Продемонстрируйте следующего вдоль стены робота преподавателю.  
	Объясните, почему он ведёт себя именно так.  
</div>


{% endblock %}
