{% extends "layout.html" %}
{% block title %}
Финансы
{% endblock %}

{% block body %}
<p>Оригинал на <a href="https://cs50.harvard.edu/x/2023/psets/9/finance/">cs50.harvard.edu</a>.
</p>
<h1>Финансы</h1>
<p>Создайте веб-сайт, через который пользователи смогут «покупать» и 
«продавать» акции, как показано ниже.
</p>
<figure class="figure">
	<img src="/psets/data/images/finance.png" class="figure-img img-fluid">
</figure>

<h2>Подготовка</h2>
<p>Если вы не совсем понимаете, что значит покупать и продавать акции (т. е. акции компании), 
загляните <a href="https://www.investopedia.com/articles/basics/06/invest1000.asp">сюда</a>, 
чтобы получить руководство.
</p>
<p>Вам надо создать C$50 Финансы — веб-приложение, с помощью которого 
вы сможете управлять портфелями акций.
Этот инструмент не только позволит вам проверять реальные цены на акции и 
стоимость портфелей, но также позволит вам покупать (хорошо, «покупать») и 
продавать (хорошо, «продавать») акции, запрашивая цены на акции.
</p>
<p>Действительно, существуют инструменты (один из них известен как IEX), 
которые позволяют загружать котировки акций через их API (интерфейс прикладного 
программирования), используя такие URL-адреса, как
https://api.iex.cloud/v1/data/core/quote/nflx?token=API_KEY .
Обратите внимание, как в этот URL-адрес встроен символ Netflix (NFLX); 
именно так IEX узнает, чьи данные возвращать.
Эта ссылка на самом деле не вернет никаких данных, поскольку IEX требует 
от вас использования ключа API,
но если бы она сделала это , вы бы увидели ответ в формате JSON 
(нотация объектов JavaScript) следующим образом:
<rep>
<code class="language-JSON">
{
  "avgTotalVolume": 15918066,
  "calculationPrice": "close",
  "change": -8.27,
  "changePercent": -0.03074,
  "close": 260.79,
  "closeSource": "official",
  "closeTime": 1667592000924,
  "companyName": "Netflix Inc.",
  "currency": "USD",
  "delayedPrice": 260.81,
  "delayedPriceTime": 1667591988947,
  "extendedChange": 0.21,
  "extendedChangePercent": 0.00081,
  "extendedPrice": 261,
  "extendedPriceTime": 1667606392772,
  "high": 274.97,
  "highSource": "15 minute delayed price",
  "highTime": 1667592000831,
  "iexAskPrice": None,
  "iexAskSize": None,
  "iexBidPrice": None,
  "iexBidSize": None,
  "iexClose": 260.85,
  "iexCloseTime": 1667591999754,
  "iexLastUpdated": None,
  "iexMarketPercent": None,
  "iexOpen": 271.67,
  "iexOpenTime": 1667568602197,
  "iexRealtimePrice": None,
  "iexRealtimeSize": None,
  "iexVolume": None,
  "lastTradeTime": 1667591999820,
  "latestPrice": 260.79,
  "latestSource": "Close",
  "latestTime": "November 4, 2022",
  "latestUpdate": 1667592000924,
  "latestVolume": 11124694,
  "low": 255.32,
  "lowSource": "15 minute delayed price",
  "lowTime": 1667584872696,
  "marketCap": 115215720136,
  "oddLotDelayedPrice": 260.81,
  "oddLotDelayedPriceTime": 1667591988947,
  "open": 271.9,
  "openTime": 1667568601785,
  "openSource": "official",
  "peRatio": 23.39,
  "previousClose": 269.06,
  "previousVolume": 7057350,
  "primaryExchange": "NASDAQ",
  "symbol": "NFLX",
  "volume": 11124694,
  "week52High": 700.99,
  "week52Low": 162.71,
  "ytdChange": -0.5978504176349512,
  "isUSMarketOpen": False
}
</code>
</pre>
Обратите внимание, что между фигурными скобками находится список пар ключ-значение, 
разделенный запятыми, с двоеточием, отделяющим каждый ключ от его значения. 
Мы собираемся сделать нечто очень похожее с Yahoo Finance.
</p>
<p>Давайте теперь обратим наше внимание на получение кода, который поможет вам с этой задачей!
</p>

<h2>Начало</h2>
<p>Войдите в <a href="https://cs50.dev">cs50.dev</a>, щелкните окно терминала и выполните cd. 
Вы получите приглашение в окне терминала, которое выглядит следующим образом:
</p>
<pre>
<code class="language-sh">
$
</code>
</pre>
<p>
Затем выполните
<pre>
<code>
wget https://vadimgb.github.io/psets/data/finance.zip
</pre>
</code>
чтобы загрузить ZIP-архив с именем finance.zip в свое кодовое пространство. 
</p>
<p>
Затем выполните
<pre>
<code>
unzip finance.zip
</code>
</pre>
чтобы создать папку под названием «finance». Вам больше не нужен ZIP-файл, 
поэтому вы можете выполнить
<pre>
<code>
rm finance.zip
</code>
</pre>
и введите «y», а затем Enter в ответ на приглашение, чтобы удалить загруженный вами ZIP-файл.
</p>
<p>Теперь наберите
<pre>
<code>
cd finance
</code>
</pre>
затем нажмите Enter, чтобы перейти (т. е. открыть) этот каталог. 
Ваше приглашение теперь должно выглядеть так, как показано ниже.
<pre>
<code>
finance/ $
</code>
</pre>
</p>
<p>Запустите ls, и вы должны увидеть несколько файлов и папок:
<pre>
<code>
app.py finance.db helpers.py requirements.txt satatic/ templates/
</code>
</pre>
Если у вас возникнут какие-либо проблемы, повторите те же действия еще 
раз и посмотрите, сможете ли вы определить, где вы ошиблись!
</p>

<h2>Запуск</h2>
<p>Запустите встроенный веб-сервер Flask (в каталоге Finance/):
<pre>
<code>
$ flask run
</code>
</pre>
Посетите URL-адрес, выведенный flask, чтобы увидеть код дистрибутива в действии. 
Однако вы пока не сможете войти или зарегистрироваться!
</p>
<p>
В каталоге finance/ выполните <code>sqlite3 finance.db</code>, чтобы открыть файл 
finance.db с помощью sqlite3.
Запустите .schema в командной строке SQLite, 
обратите внимание, что в файл finance.db входит таблица с именем users.
Взгляните на её структуру (т. е. схему).
Обратите внимание, что по умолчанию новые пользователи получат 10 000 долларов наличными.
Но если вы запустите SELECT * FROM users;, там (пока!) нет пользователей (т. е. строк) для просмотра.
</p>

<h2>Пояснения</h2>
<h3>app.py</h3>
<p>Откройте app.py. Поверх файла находится множество импортированных файлов, 
в том числе модуль SQL CS50 и несколько вспомогательных функций. Подробнее о них скоро.
</p>
<p>
После настройки <a href="https://flask.pocoo.org/">Flask</a> обратите внимание, 
как этот файл отключает кэширование ответов 
(при условии, что вы находитесь в режиме отладки, который по умолчанию 
находится в вашем кодовом пространстве code50), 
чтобы вы не внесли изменения в какой-либо файл, но ваш браузер этого не заметил.
Обратите внимание, как он настраивает Jinja с помощью специального 
«фильтра» usd — функции (определенной в helpers.py), 
которая упрощает форматирование значений в долларах США (USD).
Затем он дополнительно настраивает Flask для хранения сеансов 
в локальной файловой системе (т. е. на диске), а не в файлах cookie 
(с цифровой подписью), что используется Flask по умолчанию. 
Затем файл настраивает модуль SQL CS50 для использования Finance.db.
Обратите внимание, как он использует check_password_hash для сравнения хешей паролей пользователей.
Также обратите внимание, как login «запоминает», 
что пользователь вошёл в систему, сохраняя его или её user_id, INTEGER, в session.
Таким образом, любой route из  этого файла может проверить, 
какой пользователь (если таковой имеется) вошел в систему.
Наконец, обратите внимание, что после того, как пользователь успешно вошел в систему, 
вход будет перенаправлен на «/», и пользователь попадет на свою домашнюю страницу.
Между тем, обратите внимание, что выход из системы просто очищает session, 
фактически выходя из системы.
</p>
<p>
Обратите внимание, как большинство маршрутов «украшены» @login_required 
(функция также определена в helpers.py). 
Этот декоратор гарантирует, что если не вошедший в систему пользователь попытается посетить любой 
из этих маршрутов, он или она сначала будет перенаправлен на вход в систему.
</p>
<p>
Обратите также внимание на то, что большинство маршрутов поддерживают GET и POST. 
Несмотря на это, большинство из них (на данный момент!) просто возвращают «извинения», 
поскольку они еще не реализованы.
</p>
<h3>helpers.py</h3>
<p>Далее взгляните на helpers.py. Ах, вот реализация извинений.
Обратите внимание, как в конечном итоге отображается шаблон apology.html.
</p>
{% endblock %}
